"""
Core Type Definitions

Defines the fundamental data structures used throughout the trading system.
These dataclasses represent market data and trading signals that flow
between components (data feed -> strategy -> execution).

Main types:
    - Bar: A single price candlestick (OHLCV data)
    - Signal: A trading intention generated by a strategy
    - FillEvent: Notification that an order was executed

Helper functions:
    - rr(): Calculate risk/reward ratio for a trade

All timestamps should be timezone-aware (preferably America/New_York for
US futures). The system uses zoneinfo for timezone handling.
"""

from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Literal


# =============================================================================
# Enums
# =============================================================================


class Direction(Enum):
    """
    Trade direction indicator.

    In futures trading, you can profit in either direction:
        LONG: Buy first, sell later (profit when price goes UP)
        SHORT: Sell first, buy later (profit when price goes DOWN)

    Example:
        if price_is_going_up:
            direction = Direction.LONG
        else:
            direction = Direction.SHORT
    """

    LONG = "LONG"
    SHORT = "SHORT"

    def __str__(self) -> str:
        """Return the string value for easy printing."""
        return self.value


class EntryType(Enum):
    """
    Order entry type - how to enter the position.

    MARKET: Execute immediately at the current market price.
            Guarantees a fill but not the exact price.
            Use when you need to get in NOW (e.g., breakout confirmed).

    LIMIT: Only execute at your specified price or better.
           Guarantees your price but not a fill.
           Use when you want a specific entry (e.g., at FVG level).

    Example:
        # Enter immediately at market
        entry_type = EntryType.MARKET

        # Wait for price to come to our level
        entry_type = EntryType.LIMIT
    """

    MARKET = "MARKET"
    LIMIT = "LIMIT"

    def __str__(self) -> str:
        """Return the string value for easy printing."""
        return self.value


# =============================================================================
# Bar (Price Candlestick)
# =============================================================================


@dataclass
class Bar:
    """
    Represents a single price bar (candlestick) of market data.

    A bar summarizes all price action over a fixed time period. For example,
    a 5-minute bar shows what happened to price during those 5 minutes.

    The four prices (OHLC) tell a story:
        - Open: Where price started
        - High: The highest point reached (buyers pushed here)
        - Low: The lowest point reached (sellers pushed here)
        - Close: Where price ended (often most important)

    Visual representation of a bullish bar (close > open):

            High ─┬─ ← Upper wick (sellers rejected here)
                  │
                  █  ← Body top (close)
                  █
                  █  ← Body (green/white = bullish)
                  █
                  █  ← Body bottom (open)
                  │
            Low  ─┴─ ← Lower wick (buyers rejected here)

    Attributes:
        timestamp: When this bar OPENED (start of the time period).
                   MUST be timezone-aware! Use America/New_York for US futures.
                   Example: datetime(2024, 1, 15, 9, 30, tzinfo=ZoneInfo("America/New_York"))

        open: First traded price when the bar began.

        high: Highest price reached during the bar.
              Important for: resistance, breakout detection, stop placement.

        low: Lowest price reached during the bar.
             Important for: support, sweep detection, stop placement.

        close: Last traded price when the bar ended.
               Often considered the most significant price for analysis.

        volume: Number of contracts/shares traded during this bar.
                Higher volume = more conviction behind the move.
                Zero is valid (some feeds don't provide volume).

        symbol: The instrument this bar is for (e.g., "ES", "NQ", "MES").
                Helps when processing multiple instruments.

        timeframe: The bar's duration as a string (e.g., "1m", "5m", "1h", "1d").
                   Common values: "1m", "5m", "15m", "1h", "4h", "1d"

    Example:
        from datetime import datetime
        from zoneinfo import ZoneInfo

        bar = Bar(
            timestamp=datetime(2024, 1, 15, 9, 30, tzinfo=ZoneInfo("America/New_York")),
            open=4500.25,
            high=4502.50,
            low=4499.00,
            close=4501.75,
            volume=1500,
            symbol="ES",
            timeframe="5m"
        )

        # Check if bar is bullish (close > open)
        is_bullish = bar.close > bar.open

        # Calculate bar range in points
        bar_range = bar.high - bar.low
    """

    # -------------------------------------------------------------------------
    # Required fields
    # -------------------------------------------------------------------------

    # When this bar started - MUST be timezone-aware!
    # Use America/New_York for US futures to handle DST correctly
    timestamp: datetime

    # The four prices that define the candlestick
    open: float    # First price - where the bar began
    high: float    # Highest price - upper wick extends here
    low: float     # Lowest price - lower wick extends here
    close: float   # Last price - where the bar ended

    # -------------------------------------------------------------------------
    # Optional fields with defaults
    # -------------------------------------------------------------------------

    # Number of contracts traded during this bar (0 if not available)
    volume: int = 0

    # Which instrument this bar is for (e.g., "ES", "NQ")
    symbol: str = ""

    # Bar duration: "1m", "5m", "15m", "1h", "4h", "1d", etc.
    timeframe: str = ""

    # -------------------------------------------------------------------------
    # Computed properties
    # -------------------------------------------------------------------------

    @property
    def is_bullish(self) -> bool:
        """True if close > open (price went up during this bar)."""
        return self.close > self.open

    @property
    def is_bearish(self) -> bool:
        """True if close < open (price went down during this bar)."""
        return self.close < self.open

    @property
    def body_size(self) -> float:
        """Size of the candle body (absolute difference between open and close)."""
        return abs(self.close - self.open)

    @property
    def range(self) -> float:
        """Total range of the bar from low to high."""
        return self.high - self.low

    @property
    def upper_wick(self) -> float:
        """Size of the upper wick (shadow above the body)."""
        body_top = max(self.open, self.close)
        return self.high - body_top

    @property
    def lower_wick(self) -> float:
        """Size of the lower wick (shadow below the body)."""
        body_bottom = min(self.open, self.close)
        return body_bottom - self.low


# =============================================================================
# Signal (Trading Intention)
# =============================================================================


@dataclass
class Signal:
    """
    Represents a trading signal generated by a strategy.

    A Signal is an INTENTION to trade, not an executed order. Think of it as
    the strategy saying "I want to trade" - the execution engine then decides
    whether and how to actually place the order.

    Signals flow: Strategy.on_bar() -> Signal -> Execution Engine -> Order

    Key concepts:
        - entry_type: MARKET (now!) or LIMIT (wait for my price)
        - stop_price: Where to exit if wrong (REQUIRED for risk management)
        - targets: Where to take profits (can have multiple for scaling out)
        - reason: WHY the signal was generated (for journaling/debugging)

    Attributes:
        symbol: The instrument to trade.
                Examples: "ES" (E-mini S&P), "NQ" (Nasdaq), "MES" (Micro S&P)

        direction: LONG (buy) or SHORT (sell).
                   Use Direction.LONG or Direction.SHORT enum.

        entry_type: How to enter the trade.
                    MARKET: Execute immediately at current price
                    LIMIT: Wait for price to reach entry_price

        entry_price: The desired entry price.
                     REQUIRED for LIMIT orders (the price to wait for).
                     OPTIONAL for MARKET orders (can be None or current price as reference).

        stop_price: The stop-loss price - ALWAYS REQUIRED!
                    This is where you exit if the trade goes against you.
                    For LONG: stop_price < entry_price (exit if price falls)
                    For SHORT: stop_price > entry_price (exit if price rises)

        targets: List of take-profit prices for scaling out.
                 Example: [4510.0, 4520.0] = take 50% at 4510, rest at 4520
                 Empty list means no predefined targets (manual exit).

        time_in_force: How long the order remains active.
                       "DAY": Cancel at end of trading day (most common)
                       "GTC": Good Till Cancelled (stays until filled/cancelled)
                       "IOC": Immediate Or Cancel (fill now or cancel)

        reason: Dictionary explaining WHY this signal was generated.
                Used for trade journaling, debugging, and strategy analysis.
                Common keys:
                    - "session": Which killzone ("NY_OPEN", "LONDON")
                    - "sweep": Liquidity sweep details
                    - "bos": Break of structure details
                    - "fvg": Fair value gap details
                    - "liquidity": Liquidity level details
                    - "sdv": Standard deviation / volatility info

        tags: Optional list of string tags for categorization.
              Examples: ["A+_setup", "news_day", "trend_continuation"]
              Useful for filtering trades in analysis.

    Example:
        signal = Signal(
            symbol="ES",
            direction=Direction.LONG,
            entry_type=EntryType.LIMIT,
            entry_price=4500.00,
            stop_price=4495.00,
            targets=[4510.00, 4520.00],
            time_in_force="DAY",
            reason={
                "session": "NY_OPEN",
                "sweep": "Swept daily low at 4494.50",
                "bos": "Bullish BOS confirmed at 4498.00",
                "fvg": "Entering at FVG 4499-4501",
            },
            tags=["A+_setup", "sweep_entry"]
        )

        # Calculate risk/reward to first target
        rr_ratio = rr(signal.entry_price, signal.stop_price, signal.targets[0])
    """

    # -------------------------------------------------------------------------
    # Required fields
    # -------------------------------------------------------------------------

    # What to trade (e.g., "ES", "NQ", "MES", "MNQ")
    symbol: str

    # Which direction: Direction.LONG (buy) or Direction.SHORT (sell)
    direction: Direction

    # Stop-loss price - REQUIRED for every trade!
    # This is your "I was wrong" exit point
    stop_price: float

    # -------------------------------------------------------------------------
    # Entry configuration
    # -------------------------------------------------------------------------

    # How to enter: MARKET (immediately) or LIMIT (at specific price)
    entry_type: EntryType = EntryType.MARKET

    # Desired entry price
    # Required for LIMIT orders, optional for MARKET orders
    entry_price: float | None = None

    # -------------------------------------------------------------------------
    # Exit configuration
    # -------------------------------------------------------------------------

    # Take-profit prices for scaling out of the position
    # Example: [4510.0, 4520.0] for two profit targets
    # Empty list = no predefined targets (manual exit)
    targets: list[float] = field(default_factory=list)

    # -------------------------------------------------------------------------
    # Order settings
    # -------------------------------------------------------------------------

    # How long the order stays active
    # "DAY" = cancel at end of day (most common)
    # "GTC" = good till cancelled
    # "IOC" = immediate or cancel
    time_in_force: Literal["DAY", "GTC", "IOC"] = "DAY"

    # -------------------------------------------------------------------------
    # Metadata for analysis
    # -------------------------------------------------------------------------

    # Explanation of why this signal was generated
    # Keys: session, sweep, bos, fvg, liquidity, sdv, etc.
    reason: dict[str, str] = field(default_factory=dict)

    # Optional tags for categorization and filtering
    # Examples: ["A+_setup", "news_day", "high_volume"]
    tags: list[str] = field(default_factory=list)


# =============================================================================
# FillEvent (Order Execution Notification)
# =============================================================================


@dataclass
class FillEvent:
    """
    Represents notification that an order has been filled (executed).

    When the exchange executes your order, you receive a FillEvent with
    the details of what actually happened. This may differ from your
    original order:
        - Market orders: fill_price may differ from expected
        - Partial fills: fill_qty may be less than order quantity

    FillEvents flow: Exchange -> Broker -> FillEvent -> Strategy.on_fill()

    The strategy uses fill events to:
        - Track current position (how many contracts we hold)
        - Record actual entry price for P&L calculations
        - Adjust stops/targets based on actual fill
        - Update trade statistics

    Attributes:
        symbol: The instrument that was traded (e.g., "ES", "NQ").

        order_id: Unique identifier for the original order.
                  Used to match fills with orders.
                  Format depends on broker (e.g., "ORD-12345").

        fill_price: The actual price at which the order was executed.
                    May differ from the order price for market orders
                    or in fast-moving markets.

        fill_qty: Number of contracts/shares that were filled.
                  May be less than order quantity for partial fills.

        side: Whether this was a buy or sell execution.
              "BUY": Bought contracts (entering long or exiting short)
              "SELL": Sold contracts (entering short or exiting long)

        timestamp: When the fill occurred (timezone-aware).
                   MUST be timezone-aware for proper time tracking.

    Example:
        from datetime import datetime
        from zoneinfo import ZoneInfo

        fill = FillEvent(
            symbol="ES",
            order_id="ORD-12345",
            fill_price=4500.25,
            fill_qty=2,
            side="BUY",
            timestamp=datetime(2024, 1, 15, 9, 31, 15, tzinfo=ZoneInfo("America/New_York"))
        )

        # Check if this was an entry or exit
        if fill.side == "BUY":
            print(f"Bought {fill.fill_qty} contracts at {fill.fill_price}")
    """

    # -------------------------------------------------------------------------
    # Required fields
    # -------------------------------------------------------------------------

    # What was traded
    symbol: str

    # Unique ID linking this fill to the original order
    order_id: str

    # The actual execution price (may differ from order price)
    fill_price: float

    # Number of contracts filled (may be partial)
    fill_qty: int

    # "BUY" or "SELL" - which side of the trade
    side: Literal["BUY", "SELL"]

    # When the fill occurred - MUST be timezone-aware!
    timestamp: datetime


# =============================================================================
# Helper Functions
# =============================================================================


def rr(entry: float, stop: float, target: float) -> float:
    """
    Calculate the Risk/Reward ratio for a trade.

    Risk/Reward (R:R) tells you how much you stand to gain relative to
    how much you're risking. It's one of the most important metrics in trading.

    Formula:
        R:R = Reward / Risk
        Risk = |entry - stop|
        Reward = |target - entry|

    Example:
        Entry: 100, Stop: 95, Target: 115
        Risk = |100 - 95| = 5
        Reward = |115 - 100| = 15
        R:R = 15 / 5 = 3.0 (risking $5 to make $15)

    What the numbers mean:
        - R:R = 1.0: Risking $1 to make $1 (break-even at 50% win rate)
        - R:R = 2.0: Risking $1 to make $2 (profitable at 34% win rate)
        - R:R = 3.0: Risking $1 to make $3 (profitable at 25% win rate)

    ICT methodology typically requires R:R >= 2.0

    Args:
        entry: The entry price for the trade.
        stop: The stop-loss price.
        target: The take-profit target price.

    Returns:
        The risk/reward ratio as a float.
        Returns 0.0 if risk is zero (would cause division by zero).

    Examples:
        # Long trade: buying at 100, stop at 95, target at 110
        rr(100, 95, 110)  # Returns 2.0 (risking 5 to make 10)

        # Short trade: selling at 100, stop at 105, target at 90
        rr(100, 105, 90)  # Returns 2.0 (risking 5 to make 10)

        # Checking if trade meets minimum R:R requirement
        if rr(entry, stop, target) >= 2.0:
            print("Trade meets R:R requirement")
    """
    # Calculate the risk (distance from entry to stop)
    risk = abs(entry - stop)

    # Avoid division by zero
    if risk == 0:
        return 0.0

    # Calculate the reward (distance from entry to target)
    reward = abs(target - entry)

    # Return the ratio
    return reward / risk


def validate_signal(signal: Signal) -> list[str]:
    """
    Validate a Signal for common issues.

    Checks for logical errors that would cause problems during execution.
    Returns a list of error messages (empty list = signal is valid).

    This is a helper for debugging and testing, not a hard requirement.

    Args:
        signal: The Signal to validate.

    Returns:
        List of error message strings. Empty list means valid.

    Example:
        errors = validate_signal(my_signal)
        if errors:
            for error in errors:
                print(f"Signal error: {error}")
        else:
            print("Signal is valid!")
    """
    errors: list[str] = []

    # Check stop placement relative to entry for LIMIT orders
    if signal.entry_type == EntryType.LIMIT and signal.entry_price is not None:
        if signal.direction == Direction.LONG:
            if signal.stop_price >= signal.entry_price:
                errors.append(
                    f"LONG stop ({signal.stop_price}) must be below entry ({signal.entry_price})"
                )
        else:  # SHORT
            if signal.stop_price <= signal.entry_price:
                errors.append(
                    f"SHORT stop ({signal.stop_price}) must be above entry ({signal.entry_price})"
                )

    # Check targets are in the right direction
    if signal.entry_price is not None:
        for i, target in enumerate(signal.targets):
            if signal.direction == Direction.LONG:
                if target <= signal.entry_price:
                    errors.append(
                        f"LONG target[{i}] ({target}) must be above entry ({signal.entry_price})"
                    )
            else:  # SHORT
                if target >= signal.entry_price:
                    errors.append(
                        f"SHORT target[{i}] ({target}) must be below entry ({signal.entry_price})"
                    )

    # Check LIMIT orders have an entry price
    if signal.entry_type == EntryType.LIMIT and signal.entry_price is None:
        errors.append("LIMIT order requires entry_price")

    return errors
