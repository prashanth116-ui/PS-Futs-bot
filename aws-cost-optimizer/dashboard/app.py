"""Streamlit dashboard main application."""

import streamlit as st
import sys
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

st.set_page_config(
    page_title="AWS Cost Optimizer",
    page_icon="ðŸ’°",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS
st.markdown("""
    <style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1F4E79;
        margin-bottom: 1rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        margin-bottom: 0.5rem;
    }
    .savings-positive {
        color: #28a745;
        font-weight: bold;
    }
    .savings-negative {
        color: #dc3545;
        font-weight: bold;
    }
    </style>
""", unsafe_allow_html=True)


def main():
    st.markdown('<div class="main-header">AWS Cost Optimizer Dashboard</div>', unsafe_allow_html=True)

    # Sidebar for data source selection
    with st.sidebar:
        st.header("Data Source")

        source = st.radio(
            "Select data source:",
            ["Upload Report", "Live Analysis"]
        )

        if source == "Upload Report":
            uploaded_file = st.file_uploader(
                "Upload Excel report",
                type=["xlsx", "xls"]
            )
            if uploaded_file:
                st.session_state["report_file"] = uploaded_file
                st.success("Report loaded!")

        else:
            st.subheader("AWS Connection")
            region = st.selectbox(
                "Region",
                ["us-east-1", "us-east-2", "us-west-1", "us-west-2",
                 "eu-west-1", "eu-central-1", "ap-southeast-1", "ap-northeast-1"]
            )

            analysis_months = st.slider(
                "Analysis period (months)",
                min_value=1,
                max_value=12,
                value=3
            )

            st.subheader("Filters")
            gsi_filter = st.text_input("GSI (comma-separated)")
            env_filter = st.multiselect(
                "Environment",
                ["Production", "Staging", "Development", "Test"]
            )

            if st.button("Run Analysis", type="primary"):
                st.session_state["run_analysis"] = True

        st.divider()
        st.caption("AWS Cost Optimizer v1.0")

    # Main content
    if "report_file" in st.session_state or st.session_state.get("run_analysis"):
        display_dashboard()
    else:
        display_welcome()


def display_welcome():
    """Display welcome page when no data is loaded."""
    col1, col2 = st.columns(2)

    with col1:
        st.header("Welcome!")
        st.markdown("""
        This dashboard helps you:

        - **Analyze** your AWS EC2 resource utilization
        - **Identify** oversized and undersized instances
        - **Calculate** potential cost savings
        - **Generate** rightsizing recommendations

        ### Getting Started

        1. **Upload a report** generated by the CLI tool, or
        2. **Connect to AWS** for live analysis

        Use the sidebar to select your data source.
        """)

    with col2:
        st.header("Quick Stats")
        st.info("No data loaded yet. Upload a report or run an analysis to see insights.")


def display_dashboard():
    """Display the main dashboard with analysis results."""
    import pandas as pd

    # Load data from uploaded file or session state
    if "report_file" in st.session_state:
        df = pd.read_excel(st.session_state["report_file"], sheet_name="Server Details")
        summary_df = pd.read_excel(st.session_state["report_file"], sheet_name="Executive Summary", header=None)
    else:
        st.warning("Live analysis not yet implemented. Please upload a report.")
        return

    # Key Metrics Row
    st.header("Overview")

    col1, col2, col3, col4 = st.columns(4)

    with col1:
        st.metric(
            label="Total Servers",
            value=len(df)
        )

    with col2:
        if "current_monthly" in df.columns:
            total_spend = df["current_monthly"].sum()
            st.metric(
                label="Current Monthly Spend",
                value=f"${total_spend:,.0f}"
            )

    with col3:
        if "monthly_savings" in df.columns:
            total_savings = df[df["monthly_savings"] > 0]["monthly_savings"].sum()
            st.metric(
                label="Potential Monthly Savings",
                value=f"${total_savings:,.0f}",
                delta=f"-{(total_savings/total_spend*100):.1f}%" if total_spend > 0 else None,
                delta_color="inverse"
            )

    with col4:
        if "classification" in df.columns:
            oversized = len(df[df["classification"] == "oversized"])
            st.metric(
                label="Oversized Instances",
                value=oversized
            )

    st.divider()

    # Tabs for different views
    tab1, tab2, tab3, tab4 = st.tabs([
        "Server Analysis",
        "Recommendations",
        "Cost Breakdown",
        "Contention"
    ])

    with tab1:
        display_server_analysis(df)

    with tab2:
        display_recommendations(df)

    with tab3:
        display_cost_breakdown(df)

    with tab4:
        display_contention(df)


def display_server_analysis(df):
    """Display server analysis tab."""
    import plotly.express as px

    st.subheader("Server Classification")

    if "classification" not in df.columns:
        st.warning("Classification data not available")
        return

    # Classification pie chart
    col1, col2 = st.columns([1, 2])

    with col1:
        class_counts = df["classification"].value_counts()
        fig = px.pie(
            values=class_counts.values,
            names=class_counts.index,
            color=class_counts.index,
            color_discrete_map={
                "oversized": "#28a745",
                "right_sized": "#6c757d",
                "undersized": "#dc3545",
                "unknown": "#ffc107"
            }
        )
        fig.update_layout(height=300)
        st.plotly_chart(fig, use_container_width=True)

    with col2:
        # Filter options
        selected_class = st.multiselect(
            "Filter by classification:",
            options=df["classification"].unique(),
            default=df["classification"].unique()
        )

        filtered_df = df[df["classification"].isin(selected_class)]

        st.dataframe(
            filtered_df[["hostname", "instance_type", "cpu_p95", "memory_p95", "classification"]],
            use_container_width=True,
            height=300
        )

    # CPU vs Memory scatter plot
    st.subheader("Resource Utilization")

    if "cpu_p95" in df.columns and "memory_p95" in df.columns:
        fig = px.scatter(
            df,
            x="cpu_p95",
            y="memory_p95",
            color="classification",
            hover_data=["hostname", "instance_type"],
            color_discrete_map={
                "oversized": "#28a745",
                "right_sized": "#6c757d",
                "undersized": "#dc3545",
                "unknown": "#ffc107"
            },
            labels={"cpu_p95": "CPU P95 (%)", "memory_p95": "Memory P95 (%)"}
        )

        # Add threshold lines
        fig.add_hline(y=75, line_dash="dash", line_color="orange", annotation_text="Memory Threshold")
        fig.add_vline(x=70, line_dash="dash", line_color="orange", annotation_text="CPU Threshold")

        fig.update_layout(height=400)
        st.plotly_chart(fig, use_container_width=True)


def display_recommendations(df):
    """Display recommendations tab."""
    import plotly.express as px

    st.subheader("Rightsizing Recommendations")

    # Filter to servers with recommendations
    if "recommended_type" not in df.columns:
        st.warning("Recommendation data not available")
        return

    recs_df = df[df["recommended_type"].notna()].copy()

    if len(recs_df) == 0:
        st.info("All servers are appropriately sized!")
        return

    # Sort by savings
    recs_df = recs_df.sort_values("monthly_savings", ascending=False)

    # Top recommendations table
    st.markdown("### Top Recommendations")

    display_cols = ["hostname", "instance_type", "recommended_type",
                   "classification", "monthly_savings", "confidence", "risk_level"]
    available_cols = [c for c in display_cols if c in recs_df.columns]

    st.dataframe(
        recs_df[available_cols].head(20),
        use_container_width=True,
        column_config={
            "monthly_savings": st.column_config.NumberColumn(
                "Monthly Savings",
                format="$%.2f"
            ),
            "confidence": st.column_config.ProgressColumn(
                "Confidence",
                format="%.0f%%",
                min_value=0,
                max_value=1
            )
        }
    )

    # Savings bar chart
    st.markdown("### Savings by Server")

    top_20 = recs_df.head(20)
    fig = px.bar(
        top_20,
        x="hostname" if "hostname" in top_20.columns else "server_id",
        y="monthly_savings",
        color="classification",
        color_discrete_map={
            "oversized": "#28a745",
            "undersized": "#dc3545"
        }
    )
    fig.update_layout(height=400, xaxis_tickangle=45)
    st.plotly_chart(fig, use_container_width=True)


def display_cost_breakdown(df):
    """Display cost breakdown tab."""
    import plotly.express as px

    st.subheader("Cost Analysis")

    if "current_monthly" not in df.columns:
        st.warning("Cost data not available")
        return

    col1, col2 = st.columns(2)

    with col1:
        st.markdown("### Current vs. Optimized Spend")

        current = df["current_monthly"].sum()
        savings = df[df["monthly_savings"] > 0]["monthly_savings"].sum()
        optimized = current - savings

        fig = px.bar(
            x=["Current", "Optimized"],
            y=[current, optimized],
            color=["Current", "Optimized"],
            color_discrete_map={"Current": "#6c757d", "Optimized": "#28a745"}
        )
        fig.update_layout(height=300, showlegend=False)
        st.plotly_chart(fig, use_container_width=True)

    with col2:
        st.markdown("### Cost by Instance Type")

        if "instance_type" in df.columns:
            by_type = df.groupby("instance_type")["current_monthly"].sum().sort_values(ascending=False).head(10)

            fig = px.pie(
                values=by_type.values,
                names=by_type.index
            )
            fig.update_layout(height=300)
            st.plotly_chart(fig, use_container_width=True)

    # 12-month projection
    st.markdown("### 12-Month Savings Projection")

    months = list(range(1, 13))
    cumulative = [savings * m for m in months]

    fig = px.line(
        x=months,
        y=cumulative,
        labels={"x": "Month", "y": "Cumulative Savings ($)"}
    )
    fig.update_layout(height=300)
    st.plotly_chart(fig, use_container_width=True)


def display_contention(df):
    """Display contention analysis tab."""
    st.subheader("Resource Contention")

    if "has_contention" not in df.columns:
        st.warning("Contention data not available")
        return

    contention_df = df[df["has_contention"] == True]

    if len(contention_df) == 0:
        st.success("No resource contention detected!")
        return

    st.warning(f"Found {len(contention_df)} servers with resource contention")

    # Contention table
    display_cols = ["hostname", "instance_type", "contention_events",
                   "contention_hours", "cpu_p95", "memory_p95"]
    available_cols = [c for c in display_cols if c in contention_df.columns]

    st.dataframe(
        contention_df[available_cols].sort_values("contention_events", ascending=False),
        use_container_width=True
    )


if __name__ == "__main__":
    main()
